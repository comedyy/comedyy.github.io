## 需要的行为
1. 可以控制玩家移动，躲避障碍，躲避敌人，去拾取地面的物件。

### 步骤：
0. 我们需要先看下周围有哪些东西，所以我们玩家周围的N*N范围作为玩家的视野空间，存储再K中。
1. 需要计算地面的obstacle值， 我们可以定一些obstacle值=9999，储存再K中.
2. 再计算怪物的威胁值，同样增加到K中。 这样K中的数值越大，越表示这个地方不能走。
这个威胁值主要是怪物(或者飞行子弹，延迟爆炸)的伤害值以及它造成伤害的时间计算出来的。
比如一个子弹是100伤害，它的威胁范围是一个长方形，以子弹中心点为起点，飞行方向以及飞行速度计算出这个长方形的区域。
从起点开始，威胁值是100， 然后到飞行的尾端，递减到20。然后长方形的宽就从中心点的值递减到中心点的50%。
50 50  40 30 20 10
50 100 80 60 40 20
50 50  40 30 20 10
差不多就是这种方式，100是子弹的中心点，沿着80，60，40，20的方向飞行。
这样可以让玩家碰到20的时候躲避来。
3. 这样就得到一个N*N范围的K值了。玩家在它的中心点。
4. 我们就得到了它周围的信息了。
5. 这个时候玩家有两种行为，一种是躲避怪物，另外一个是移动到周围找东西吃。
6. 躲避怪物的逻辑是 从玩家这个位置找到一个空位。
这个逻辑是我们需要构建周围的一个怪物边界。这样我们如果被怪物威胁到，只要控制我们的角色走到怪物边界去就可以了。（保证跟怪物的距离不远但是不会被怪物打到）
怪物的边界的逻辑是遍历N*N的顶点，
    1. 它必须是个空位。
    2. 它周围必须有个点的威胁之>0
这样就找到了一个对的边界值。我们只要通过流体场算法找到最近的边界的路基就可以了。
7. 拣地上的东西是上层逻辑了。

这里主要有几个要点。
我们找周围的怪物使用的是 kdTree，如果怪物数量多，性能很好。
还有一点就是 我们需要优化算法来实现更好的性能。 
1. openlist 使用queue而不是使用List。防止一直内存移动。  // 目前看来减少了 2/3的时间。
2. 边界问题，我们需要一直判断是否越界，可以考虑外面多一圈空间，这样只需要在加入到openlist的时候判断边界就可以了。 // 在1的基础上又减少了 1/3


