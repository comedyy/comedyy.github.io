## 浮点数的结构

表示方式：

​	（-1）<sup>s</sup> * (1.f) <sup> (e -127)</sup>

s为符号，f为尾数， e为阶码



​        31     30-23    22-0

float    符号位(s)   阶码(e)     尾数(f)

​        63     62-52    51-0

double   符号位   阶码     尾数

在内存中以二进制的科学计数法记录。

1.1111111 * 2^5 = 111111.11 = 2^5 + 2^4 + 2^3 + 2 ^2 + 2^1 + 2^0 + 2^-1+ 2^-2

### 符号(s)

0就是正数， 1为负数

### 尾数(f):

有23位，其实是24位，只是默认1开头，内存中不记录第一位1，而是记录之后的1.

比如上面的，尾数就是11111110000000000000000---> 反正后面1越多，精度越高，表示的数越精确

### 阶码(e)：

真实阶码 = 阶码 - 127（0x7f），实际用到的是 1-245， 0跟255有其他用处。

直接用阶码的原码值 -127 标示为真正的阶码。如阶码 132 就是用来标示 5， 因为 132 - 127 = 5 ， 阶码标示就是 10000100

内存								 								十进制

0 00000000 00000000000000000000000      0			1.0 * 2^-127

0 01111101 00000000000000000000000	0.25

0 01111110 00000000000000000000000	0.5

0 01111111 00000000000000000000000	1

0 10000000 00000000000000000000000	2

0 10000001 00000000000000000000000	4



e = 0  && f = 0, 表示为0

e = 255 && f = 0 表示为 无穷大

e = 255 && f!= 0 表示为NAN



### 精度问题

在e达到 127 + 23的时候， 浮点数就没有了小数点了。因为对应小数点的f只有23位。当e继续变大的时候，float 跟 能表示的精度将少于 int。

比如int.max = 2147483647,但是转成float之后就变成了0 10011110 00000000000000000000000，这个是int.max + 1,不仅int.max 为那个值，int.max - 1, int.max - 2 都是那个值

当float表示比较大的数字的时候，容易跟int形成断层。即float无法表达特定的整数。



```c#
float x = float.NaN;
byte[] bs = BitConverter.GetBytes(x);
foreach (var item in bs)
{
	Console.Write("-" + Convert.ToString(item, 2).PadLeft(8, '0'));
}
```



输出float的内存形式。因为是小端模式，所以从左到右输出。