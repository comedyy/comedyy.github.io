# litnetlib 库。

它帮我们实现了可靠的UDP。看起来还不错。

### 主要功能。
1. 它而已面向连接或者无连接。连接需要三次握手，无连接则直接发送消息。
2. 面向连接的也有几个投递规则，主要是两个规则，可靠跟顺序，可靠就是发送了一定要收到，顺序就是收到的东西一定要按顺序，收到旧的旧不处理。这些规则是peer中的各种channel。
3. 它实现了 分包功能，一般情况下，udp发送包不能超过mtu，通过在逻辑包头上加一个分包的标志，来实现分包功能，
4. 它实现了一个合包功能，这个很重要，因为udp的包头很大，如果发送的数很少，那么就会造成流量浪费。如果把同一帧发送给同一个目标的几个包合并起来，那么就可以减少流量，原本的udp是没有合并包体的功能。
5. 它实现了ipv6的功能，这个其实很管用，如果是ipv6的客户端访问服务器，那么他们将获得支持。（服务器非常需要）
6. 自动mtu检测。提供了几种常见的mtu，一个一个去检测。看看能不能收到，如果能收到就继续检查更大的mtu。当然最大不能超过1500。超过一定次数没收到就结束。
7. 提供crc验证。
8. UDP 打洞？（未验证）(似乎有点意思)
9. 丢包与延迟统计。以及各种统计。(未验证)
10. 局域网广播（用于游戏发现）
11. 自动切换网络。（这个还是很不错，服务器发现未知的发送者，发送消息包给它告诉它找不到发送者，客户端发送自己的token给服务器，服务器重新关联peer）

### 实现分析
1. 如何实现可靠的传输。有一个窗口机制。发送的包放入Ongoing队列。等待放入pendingList。 pengdingList就是一个窗口，64个对象。收到一个ack之后，就会从penglist中把它删掉。
2. ack也会把pendingList中的64个窗口放在8个int中传输。更快的ack判断。 服务器收到包N，那么服务器会把 N之前的64个包的ack状态发给客户端。客户端就知道哪些包被ack过了。
3. 重传的间隔：25ms + ping * 2.1f。 如果ping = 70，那么这个值差不多是170。
4. 一秒一个ping。

### 存在问题
1. 服务器中最好开启 NativeSocket，不然出现过 ReceiveSocket卡死问题。 (新版本已经解决了，因为有时候会receive 0个字节导致死循环。)
2. 有时候ping会很高，甚至卡住。 好像是socket receive那个线程，如果给他卡一下，就会出问题。  明天要看一下  一定要看。  继续做流量分析。  （是因为数据无法即使从buffer中读取出来）